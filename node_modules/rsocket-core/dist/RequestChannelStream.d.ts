/// <reference types="node" />
import { CancelFrame, ErrorFrame, ExtFrame, FrameTypes, PayloadFrame, RequestChannelFrame, RequestNFrame } from "./Frames";
import { LeaseManager } from "./Lease";
import * as Reassembler from "./Reassembler";
import { Cancellable, OnExtensionSubscriber, OnNextSubscriber, OnTerminalSubscriber, Payload, Requestable } from "./RSocket";
import { Stream, StreamFrameHandler, StreamLifecycleHandler } from "./Transport";
export declare class RequestChannelRequesterStream implements Cancellable, Requestable, OnTerminalSubscriber, OnNextSubscriber, OnExtensionSubscriber, StreamFrameHandler, StreamLifecycleHandler, Reassembler.FragmentsHolder {
    private readonly payload;
    private isComplete;
    private readonly receiver;
    private readonly fragmentSize;
    private initialRequestN;
    private readonly leaseManager?;
    readonly streamType = FrameTypes.REQUEST_CHANNEL;
    private stream;
    private inboundDone;
    private outboundDone;
    private hasExtension;
    private extendedType;
    private extendedContent;
    private flags;
    hasFragments: boolean;
    data: Buffer;
    metadata: Buffer;
    streamId: number;
    constructor(payload: Payload, isComplete: boolean, receiver: OnTerminalSubscriber & OnNextSubscriber & OnExtensionSubscriber & Requestable & Cancellable, fragmentSize: number, initialRequestN: number, leaseManager?: LeaseManager);
    handleReady(streamId: number, stream: Stream): boolean;
    handleReject(error: Error): void;
    handle(frame: PayloadFrame | ErrorFrame | CancelFrame | RequestNFrame | ExtFrame): void;
    request(n: number): void;
    cancel(): void;
    onNext(payload: Payload, isComplete: boolean): void;
    onComplete(): void;
    onError(error: Error): void;
    onExtension(extendedType: number, content: Buffer | null | undefined, canBeIgnored: boolean): void;
    close(error?: Error): void;
}
export declare class RequestChannelResponderStream implements Cancellable, Requestable, OnExtensionSubscriber, OnTerminalSubscriber, OnNextSubscriber, Cancellable, StreamFrameHandler, Reassembler.FragmentsHolder {
    readonly streamId: number;
    private readonly stream;
    private readonly fragmentSize;
    private readonly handler;
    readonly streamType = FrameTypes.REQUEST_CHANNEL;
    private receiver?;
    private readonly initialRequestN;
    private readonly isComplete;
    private inboundDone;
    private defferedError;
    private outboundDone;
    hasFragments: boolean;
    data: Buffer;
    metadata: Buffer;
    constructor(streamId: number, stream: Stream, fragmentSize: number, handler: (payload: Payload, initialRequestN: number, isComplete: boolean, senderStream: Cancellable & Requestable & OnExtensionSubscriber & OnTerminalSubscriber & OnNextSubscriber) => Cancellable & Requestable & OnExtensionSubscriber & OnTerminalSubscriber & OnNextSubscriber, frame: RequestChannelFrame);
    handle(frame: CancelFrame | ErrorFrame | PayloadFrame | RequestNFrame | ExtFrame): void;
    onError(error: Error): void;
    onNext(payload: Payload, isCompletion: boolean): void;
    onComplete(): void;
    onExtension(extendedType: number, content: Buffer, canBeIgnored: boolean): void;
    request(n: number): void;
    cancel(): void;
    close(error?: Error): void;
}
