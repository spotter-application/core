/// <reference types="node" />
import { ErrorFrame, KeepAliveFrame, LeaseFrame, MetadataPushFrame, RequestChannelFrame, RequestFnfFrame, RequestResponseFrame, RequestStreamFrame, ResumeFrame, ResumeOkFrame, SetupFrame } from "./Frames";
import { LeaseManager } from "./Lease";
import { Cancellable, OnExtensionSubscriber, OnNextSubscriber, OnTerminalSubscriber, Payload, Requestable, RSocket } from "./RSocket";
import { ConnectionFrameHandler, DuplexConnection, FrameHandler, Multiplexer, Outbound, Stream, StreamFrameHandler, StreamLifecycleHandler, StreamRequestHandler } from "./Transport";
export declare class RSocketRequester implements RSocket {
    private readonly connection;
    private readonly fragmentSize;
    private readonly leaseManager;
    constructor(connection: DuplexConnection, fragmentSize: number, leaseManager: LeaseManager | undefined | null);
    fireAndForget(payload: Payload, responderStream: OnTerminalSubscriber): Cancellable;
    requestResponse(payload: Payload, responderStream: OnTerminalSubscriber & OnNextSubscriber & OnExtensionSubscriber): Cancellable & OnExtensionSubscriber;
    requestStream(payload: Payload, initialRequestN: number, responderStream: OnTerminalSubscriber & OnNextSubscriber & OnExtensionSubscriber): Requestable & OnExtensionSubscriber & Cancellable;
    requestChannel(payload: Payload, initialRequestN: number, isCompleted: boolean, responderStream: OnTerminalSubscriber & OnNextSubscriber & OnExtensionSubscriber & Requestable & Cancellable): OnTerminalSubscriber & OnNextSubscriber & OnExtensionSubscriber & Requestable & Cancellable;
    metadataPush(metadata: Buffer, responderStream: OnTerminalSubscriber): void;
    close(error?: Error): void;
    onClose(callback: any): void;
}
export declare class LeaseHandler implements LeaseManager {
    private readonly maxPendingRequests;
    private readonly multiplexer;
    private readonly pendingRequests;
    private expirationTime;
    private availableLease;
    constructor(maxPendingRequests: number, multiplexer: Multiplexer);
    handle(frame: LeaseFrame): void;
    requestLease(handler: StreamFrameHandler & StreamLifecycleHandler): void;
    cancelRequest(handler: StreamFrameHandler & StreamLifecycleHandler): void;
}
export declare class DefaultStreamRequestHandler implements StreamRequestHandler {
    private rsocket;
    private fragmentSize;
    constructor(rsocket: Partial<RSocket>, fragmentSize: number);
    handle(frame: RequestFnfFrame | RequestResponseFrame | RequestStreamFrame | RequestChannelFrame, stream: Stream): void;
    rejectRequest(streamId: number, stream: Stream): void;
    close(): void;
}
export declare class DefaultConnectionFrameHandler implements ConnectionFrameHandler {
    private readonly connection;
    private readonly keepAliveHandler;
    private readonly keepAliveSender;
    private readonly leaseHandler;
    private readonly rsocket;
    constructor(connection: DuplexConnection, keepAliveHandler: KeepAliveHandler, keepAliveSender: KeepAliveSender | undefined, leaseHandler: LeaseHandler | undefined, rsocket: Partial<RSocket>);
    handle(frame: SetupFrame | ResumeFrame | ResumeOkFrame | LeaseFrame | KeepAliveFrame | ErrorFrame | MetadataPushFrame): void;
    pause(): void;
    resume(): void;
    close(error?: Error): void;
}
export declare class KeepAliveHandler implements FrameHandler {
    private readonly connection;
    private readonly keepAliveTimeoutDuration;
    private readonly outbound;
    private keepAliveLastReceivedMillis;
    private activeTimeout;
    private state;
    constructor(connection: DuplexConnection, keepAliveTimeoutDuration: number);
    handle(frame: KeepAliveFrame): void;
    start(): void;
    pause(): void;
    close(): void;
    private timeoutCheck;
}
export declare class KeepAliveSender {
    private readonly outbound;
    private readonly keepAlivePeriodDuration;
    private activeInterval;
    private state;
    constructor(outbound: Outbound, keepAlivePeriodDuration: number);
    private sendKeepAlive;
    start(): void;
    pause(): void;
    close(): void;
}
